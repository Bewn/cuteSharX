From fe7cba4e25a404eb5f53322653d71b4b89cfe9d4 Mon Sep 17 00:00:00 2001
From: Luke Shumaker <lukeshu@parabola.nu>
Date: Fri, 7 Jul 2017 15:15:14 -0400
Subject: [PATCH 07/38] nspawn: nspawn-cgroup.{c,h}:
 s/unified_requested/inner_cgver/

---
 src/nspawn/nspawn-cgroup.c | 32 ++++++++++++++++----------------
 src/nspawn/nspawn-cgroup.h | 10 +++++-----
 2 files changed, 21 insertions(+), 21 deletions(-)

diff --git a/src/nspawn/nspawn-cgroup.c b/src/nspawn/nspawn-cgroup.c
index 4a3cd29094..fde8e67353 100644
--- a/src/nspawn/nspawn-cgroup.c
+++ b/src/nspawn/nspawn-cgroup.c
@@ -43,7 +43,7 @@ static int chown_cgroup_path(const char *path, uid_t uid_shift) {
         return 0;
 }
 
-int chown_cgroup(pid_t pid, CGroupUnified unified_requested, uid_t uid_shift) {
+int chown_cgroup(pid_t pid, CGroupUnified inner_cgver, uid_t uid_shift) {
         _cleanup_free_ char *path = NULL, *fs = NULL;
         int r;
 
@@ -59,7 +59,7 @@ int chown_cgroup(pid_t pid, CGroupUnified unified_requested, uid_t uid_shift) {
         if (r < 0)
                 return log_error_errno(r, "Failed to chown() cgroup %s: %m", fs);
 
-        if (unified_requested == CGROUP_UNIFIED_SYSTEMD) {
+        if (inner_cgver == CGROUP_UNIFIED_SYSTEMD) {
                 _cleanup_free_ char *lfs = NULL;
                 /* Always propagate access rights from unified to legacy controller */
 
@@ -75,7 +75,7 @@ int chown_cgroup(pid_t pid, CGroupUnified unified_requested, uid_t uid_shift) {
         return 0;
 }
 
-int sync_cgroup(pid_t pid, CGroupUnified unified_requested, uid_t uid_shift) {
+int sync_cgroup(pid_t pid, CGroupUnified inner_cgver, uid_t uid_shift) {
         _cleanup_free_ char *cgroup = NULL;
         char tree[] = "/tmp/unifiedXXXXXX", pid_string[DECIMAL_STR_MAX(pid) + 1];
         bool undo_mount = false;
@@ -85,7 +85,7 @@ int sync_cgroup(pid_t pid, CGroupUnified unified_requested, uid_t uid_shift) {
         unified_controller = cg_unified_controller(SYSTEMD_CGROUP_CONTROLLER);
         if (unified_controller < 0)
                 return log_error_errno(unified_controller, "Failed to determine whether the systemd hierarchy is unified: %m");
-        if ((unified_controller > 0) == (unified_requested >= CGROUP_UNIFIED_SYSTEMD))
+        if ((unified_controller > 0) == (inner_cgver >= CGROUP_UNIFIED_SYSTEMD))
                 return 0;
 
         /* When the host uses the legacy cgroup setup, but the
@@ -140,7 +140,7 @@ finish:
         return r;
 }
 
-int create_subcgroup(pid_t pid, bool keep_unit, CGroupUnified unified_requested) {
+int create_subcgroup(pid_t pid, bool keep_unit, CGroupUnified inner_cgver) {
         _cleanup_free_ char *cgroup = NULL;
         CGroupMask supported;
         const char *payload;
@@ -295,7 +295,7 @@ static int mount_legacy_cgroup_hierarchy(
 /* Mount a legacy cgroup hierarchy when cgroup namespaces are supported. */
 static int mount_legacy_cgns_supported(
                 const char *dest,
-                CGroupUnified unified_requested,
+                CGroupUnified inner_cgver,
                 bool userns,
                 uid_t uid_shift,
                 uid_t uid_range,
@@ -382,7 +382,7 @@ static int mount_legacy_cgns_supported(
         }
 
 skip_controllers:
-        if (unified_requested >= CGROUP_UNIFIED_SYSTEMD) {
+        if (inner_cgver >= CGROUP_UNIFIED_SYSTEMD) {
                 r = mount_legacy_cgroup_hierarchy("", SYSTEMD_CGROUP_CONTROLLER_HYBRID, "unified", false);
                 if (r < 0)
                         return r;
@@ -402,7 +402,7 @@ skip_controllers:
 /* Mount legacy cgroup hierarchy when cgroup namespaces are unsupported. */
 static int mount_legacy_cgns_unsupported(
                 const char *dest,
-                CGroupUnified unified_requested,
+                CGroupUnified inner_cgver,
                 bool userns,
                 uid_t uid_shift,
                 uid_t uid_range,
@@ -491,7 +491,7 @@ static int mount_legacy_cgns_unsupported(
         }
 
 skip_controllers:
-        if (unified_requested >= CGROUP_UNIFIED_SYSTEMD) {
+        if (inner_cgver >= CGROUP_UNIFIED_SYSTEMD) {
                 r = mount_legacy_cgroup_hierarchy(dest, SYSTEMD_CGROUP_CONTROLLER_HYBRID, "unified", false);
                 if (r < 0)
                         return r;
@@ -534,19 +534,19 @@ static int mount_unified_cgroups(const char *dest) {
 
 int mount_cgroups(
                 const char *dest,
-                CGroupUnified unified_requested,
+                CGroupUnified inner_cgver,
                 bool userns,
                 uid_t uid_shift,
                 uid_t uid_range,
                 const char *selinux_apifs_context,
                 bool use_cgns) {
 
-        if (unified_requested >= CGROUP_UNIFIED_ALL)
+        if (inner_cgver >= CGROUP_UNIFIED_ALL)
                 return mount_unified_cgroups(dest);
         if (use_cgns)
-                return mount_legacy_cgns_supported(dest, unified_requested, userns, uid_shift, uid_range, selinux_apifs_context);
+                return mount_legacy_cgns_supported(dest, inner_cgver, userns, uid_shift, uid_range, selinux_apifs_context);
 
-        return mount_legacy_cgns_unsupported(dest, unified_requested, userns, uid_shift, uid_range, selinux_apifs_context);
+        return mount_legacy_cgns_unsupported(dest, inner_cgver, userns, uid_shift, uid_range, selinux_apifs_context);
 }
 
 static int mount_systemd_cgroup_writable_one(const char *root, const char *own) {
@@ -567,7 +567,7 @@ static int mount_systemd_cgroup_writable_one(const char *root, const char *own)
 
 int mount_systemd_cgroup_writable(
                 const char *dest,
-                CGroupUnified unified_requested) {
+                CGroupUnified inner_cgver) {
 
         _cleanup_free_ char *own_cgroup_path = NULL;
         const char *root, *own;
@@ -583,14 +583,14 @@ int mount_systemd_cgroup_writable(
         if (path_equal(own_cgroup_path, "/"))
                 return 0;
 
-        if (unified_requested >= CGROUP_UNIFIED_ALL) {
+        if (inner_cgver >= CGROUP_UNIFIED_ALL) {
 
                 root = prefix_roota(dest, "/sys/fs/cgroup");
                 own = strjoina(root, own_cgroup_path);
 
         } else {
 
-                if (unified_requested >= CGROUP_UNIFIED_SYSTEMD) {
+                if (inner_cgver >= CGROUP_UNIFIED_SYSTEMD) {
                         root = prefix_roota(dest, "/sys/fs/cgroup/unified");
                         own = strjoina(root, own_cgroup_path);
 
diff --git a/src/nspawn/nspawn-cgroup.h b/src/nspawn/nspawn-cgroup.h
index 035e8fbd0f..aaa9368338 100644
--- a/src/nspawn/nspawn-cgroup.h
+++ b/src/nspawn/nspawn-cgroup.h
@@ -6,9 +6,9 @@
 
 #include "cgroup-util.h"
 
-int chown_cgroup(pid_t pid, CGroupUnified unified_requested, uid_t uid_shift);
-int sync_cgroup(pid_t pid, CGroupUnified unified_requested, uid_t uid_shift);
-int create_subcgroup(pid_t pid, bool keep_unit, CGroupUnified unified_requested);
+int chown_cgroup(pid_t pid, CGroupUnified inner_cgver, uid_t uid_shift);
+int sync_cgroup(pid_t pid, CGroupUnified inner_cgver, uid_t uid_shift);
+int create_subcgroup(pid_t pid, bool keep_unit, CGroupUnified inner_cgver);
 
-int mount_cgroups(const char *dest, CGroupUnified unified_requested, bool userns, uid_t uid_shift, uid_t uid_range, const char *selinux_apifs_context, bool use_cgns);
-int mount_systemd_cgroup_writable(const char *dest, CGroupUnified unified_requested);
+int mount_cgroups(const char *dest, CGroupUnified inner_cgver, bool userns, uid_t uid_shift, uid_t uid_range, const char *selinux_apifs_context, bool use_cgns);
+int mount_systemd_cgroup_writable(const char *dest, CGroupUnified inner_cgver);
-- 
2.18.0

